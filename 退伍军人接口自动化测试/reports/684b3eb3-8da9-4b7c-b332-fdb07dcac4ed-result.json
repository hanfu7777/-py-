{"name": "test[case3]", "status": "failed", "statusDetails": {"message": "AssertionError: assert '长度过长' == \"\\r\\n### Erro...AME' at row 1\"\n  + 长度过长\n  - \r\n  - ### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column 'NAME' at row 1\r\n  - ### The error may exist in org/mindrive/system/dao/mapper/ArchiveDistributeBatchRecordMapper.java (best guess)\r\n  - ### The error may involve org.mindrive.system.dao.mapper.ArchiveDistributeBatchRecordMapper.insert-Inline\r\n  - ### The error occurred while setting parameters\r\n  - ### SQL: INSERT INTO ARCHIVE_DISTRIBUTE_BATCH_RECORD  ( ID, `organization_id`, `no`, `prefix`, `index`, `name`, `remark`, `status`, `creator`, `created_at` )  VALUES  ( ?,...\n  \n  ...Full output truncated (3 lines hidden), use '-vv' to show", "trace": "self = <TestCases.test_数据分发.Test_config object at 0x000002783892C7C8>\ncase = {'case_id': 4, 'expected': {'code': 400, 'data': None, 'message': '长度过长'}, 'files': {}, 'headers': {'Authorization': '...wiaWF0IjoxNjc1MTMwMzYyfQ.WY3aFj9RrSN2tTwqvcWFD366RAUXravw1LRGYm3o-uxjHnybOLFhj0UyGoKLZ1t1Jd22HVKIew8GfI0pdKiVSA'}, ...}\n\n    @pytest.mark.usefixtures('class_fixture')\n    def test(self, case):\n        # 获取全新的token------具体项目具体分析\n        if \"#token#\" in case.get(\"headers\"):\n            token = get_token.login(**settings.TOKEN)['data']\n            # 替换槽位\n            case['headers'] = case['headers'].replace(\"#token#\", token)\n        # 如果json中有##包裹的字段,就要进行替换\n        if re.findall('#.*?#', case.get('json')):\n            # 获取一个超长的名称\n            self.__class__.super_long = str(generate_random_str(256, 'random'))\n            case['json'] = replace_args_by_re(case['json'], self)\n        self.logger.info(f\"用例【{case['title']}】开始测试,这是第【{case['case_id']}】条用例\\n发起请求的地址是------>:{case['url']}\")\n        #  进行反序列化\n        case['json'] = json.loads(case['json'])\n        case['expected'] = json.loads(case['expected'])\n        case['headers'] = json.loads(case['headers'])\n        case['files'] = json.loads(case['files'])\n        # 如果需要上传文件的话\n        if case['files'].get('path', 0):\n            files = {\n                \"file\": (case['files']['filename'], open(case['files']['path'], \"rb\"), 'application/json')\n            }\n            response = send_http_requests(url=case['url'], method=case[\"method\"], headers=case['headers'],\n                                          data=case['json'], files=files)\n            response_data = response.json()\n        # 否则默认这样上传\n        else:\n            response = send_http_requests(url=case['url'], method=case[\"method\"], headers=case['headers'],\n                                          json=case['json'])\n            # 以json的形式展现\n            response_data = response.json()\n        # 断言\n        try:\n            # 状态码断言\n            assert case['expected']['code'] == int(response_data['code'])\n            print(f\"测试【{case['title']}】响应状态码断言成功\")\n            # 响应数据断言\n            assert case['expected']['message'] == response_data['message']\n            print(f\"测试【{case['title']}】数据内容断言成功\")\n        except AssertionError as e:\n            # 写入错误日志\n            self.logger.warning(f\"断言失败----期望结果是>>>>>>>:{case['expected']}-----响应结果是>>>>>>>:{response_data}\")\n            # 打印错误内容\n            print(f\"断言失败----期望结果是>>>>>>>:{case['expected']}-----响应结果是>>>>>>>:{response_data}\")\n>           raise e\n\nTestCases\\test_数据分发.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <TestCases.test_数据分发.Test_config object at 0x000002783892C7C8>\ncase = {'case_id': 4, 'expected': {'code': 400, 'data': None, 'message': '长度过长'}, 'files': {}, 'headers': {'Authorization': '...wiaWF0IjoxNjc1MTMwMzYyfQ.WY3aFj9RrSN2tTwqvcWFD366RAUXravw1LRGYm3o-uxjHnybOLFhj0UyGoKLZ1t1Jd22HVKIew8GfI0pdKiVSA'}, ...}\n\n    @pytest.mark.usefixtures('class_fixture')\n    def test(self, case):\n        # 获取全新的token------具体项目具体分析\n        if \"#token#\" in case.get(\"headers\"):\n            token = get_token.login(**settings.TOKEN)['data']\n            # 替换槽位\n            case['headers'] = case['headers'].replace(\"#token#\", token)\n        # 如果json中有##包裹的字段,就要进行替换\n        if re.findall('#.*?#', case.get('json')):\n            # 获取一个超长的名称\n            self.__class__.super_long = str(generate_random_str(256, 'random'))\n            case['json'] = replace_args_by_re(case['json'], self)\n        self.logger.info(f\"用例【{case['title']}】开始测试,这是第【{case['case_id']}】条用例\\n发起请求的地址是------>:{case['url']}\")\n        #  进行反序列化\n        case['json'] = json.loads(case['json'])\n        case['expected'] = json.loads(case['expected'])\n        case['headers'] = json.loads(case['headers'])\n        case['files'] = json.loads(case['files'])\n        # 如果需要上传文件的话\n        if case['files'].get('path', 0):\n            files = {\n                \"file\": (case['files']['filename'], open(case['files']['path'], \"rb\"), 'application/json')\n            }\n            response = send_http_requests(url=case['url'], method=case[\"method\"], headers=case['headers'],\n                                          data=case['json'], files=files)\n            response_data = response.json()\n        # 否则默认这样上传\n        else:\n            response = send_http_requests(url=case['url'], method=case[\"method\"], headers=case['headers'],\n                                          json=case['json'])\n            # 以json的形式展现\n            response_data = response.json()\n        # 断言\n        try:\n            # 状态码断言\n            assert case['expected']['code'] == int(response_data['code'])\n            print(f\"测试【{case['title']}】响应状态码断言成功\")\n            # 响应数据断言\n>           assert case['expected']['message'] == response_data['message']\nE           assert '长度过长' == \"\\r\\n### Erro...AME' at row 1\"\nE             + 长度过长\nE             - \r\nE             - ### Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MysqlDataTruncation: Data truncation: Data too long for column 'NAME' at row 1\r\nE             - ### The error may exist in org/mindrive/system/dao/mapper/ArchiveDistributeBatchRecordMapper.java (best guess)\r\nE             - ### The error may involve org.mindrive.system.dao.mapper.ArchiveDistributeBatchRecordMapper.insert-Inline\r\nE             - ### The error occurred while setting parameters\r\nE             - ### SQL: INSERT INTO ARCHIVE_DISTRIBUTE_BATCH_RECORD  ( ID, `organization_id`, `no`, `prefix`, `index`, `name`, `remark`, `status`, `creator`, `created_at` )  VALUES  ( ?,...\nE             \nE             ...Full output truncated (3 lines hidden), use '-vv' to show\n\nTestCases\\test_数据分发.py:62: AssertionError"}, "attachments": [{"name": "log", "source": "b66d46c3-3bc4-4f37-a845-c6c2cded14cd-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "case", "value": "{'case_id': 4, 'interface': '数据分发', 'title': '名称超界', 'method': 'POST', 'url': 'http://192.168.0.253:8080/gateways/archive-distribute/create', 'headers': '{\"Authorization\":\"#token#\"}', 'json': '{\"name\":\"#super_long#\",\"remark\":\"\"}', 'files': '{}', 'expected': '{\"code\":400,\"message\":\"长度过长\",\"data\":null}'}"}], "start": 1675130364503, "stop": 1675130364646, "uuid": "51066472-a547-426a-a625-78c5ba469dbd", "historyId": "cbc069450a76f86f8ddd0b98e01d0c2d", "testCaseId": "b0336637edfd285ad99604d1e6b1840b", "fullName": "TestCases.test_数据分发.Test_config#test", "labels": [{"name": "tag", "value": "@pytest.mark.usefixtures('class_fixture')"}, {"name": "parentSuite", "value": "TestCases"}, {"name": "suite", "value": "test_数据分发"}, {"name": "subSuite", "value": "Test_config"}, {"name": "host", "value": "DESKTOP-Q9GOLIL"}, {"name": "thread", "value": "18480-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "TestCases.test_数据分发"}]}